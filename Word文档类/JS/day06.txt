Day05 函数**********
一、  函数基本使用 
	概念，定义（表达式，字面量），作用
		什么是函数：
			具有某种特定功能的代码块~      //想象成工具或者工厂
			
		为什么要有函数
			1、解决代码的冗余问题，形成代码复用；
			2、可以把整个代码项目，通过函数模块化；
			3、封装代码，让函数内部的代码对外部不可见；
			
		
		函数引入
			打印等腰三角形
			

		函数定义（字面量定义和表达式定义   先定义后使用   三要素***）
			字面量定义：

				function 函数名（）{

					代码块；（函数体）
				}
				
			函数表达式定义：
				var 变量名（函数名） = function(){
					代码块；（函数体）
				}

			函数的定义：三要素：  功能（函数名，见名思意，看到了函数名就想到了这个函数的功能）
					     参数：（）里面是函数的参数，定义函数的时候要考虑这个函数是否有参数；
					     返回值：函数最终都会有一个返回值；定义函数的时候也要考虑这个函数是否需要返回值；
			
		


		函数调用	
			本质上是函数调用表达式；这个表达式整体的值就是函数定义当中return后面的值；如果函数定义当中没有写return，那么
			其实相当于默认return的是一个undefined.只是把return省略了；return关键字在函数当中一是用来返回值，二是当函数执行到
			return的时候，函数就立即结束了，即使return下面还有代码，也不再执行；


			参数：函数定义的时候我们要考虑的三要素包含了一个参数；参数在函数定义当中被称作形式参数，简称形参；
			      函数调用的时候，我们在（）当中所写的也叫做参数，叫做实际参数，简称实参；
			      函数调用的时候，我们写实际参数被称作函数传参，传参的本质是把函数调用的实参，赋值给函数定义的形参；
			      函数的实参，肯定是一个有值的东西；
			      函数定义的形参：本质上相当于在函数内部var了变量；

			函数定义：
			function add (a,b){
				
				return a + b;
				console.log('i love you! zhao li ying~');
			}
			函数调用：
			add(8,10);		
				
		
	
二、 函数的分类
	1)	无参无返回值   //通常情况下   很少有这样的函数，一般都是需要将代码模块化的时候，纯粹的去封装功能使用的；
	2)	有参无返回值   //
	3)	无参有返回值
	4)	有参有返回值

	
	

三、 强化练习

	编写求1到n的和函数
	编写函数实现求一个数的阶乘
	编写函数求数组的最大值，最小值
	封装函数加工数组，每一项加10输出
	封装函数实现打印1到N的质数;
	封装函数实现对数组进行排序	




四、  作用域
	1)	作用域概念，定义，作用，全局作用域和局部作用域（块级作用域是es6新加的）
		作用域：变量起作用的区域范围
		全局作用域和局部作用域是js当中仅存在的两种作用域（es5）

		作用域作用：隔离变量

		
	2)	全局变量和局部变量（局部变量和全局变量的坑及生命周期；）

		全局变量：定义在全局环境当中的就是全局变量（函数外部）
		局部变量：定义在局部环境当中的就是局部变量（函数内部）
		全局变量：在整个程序所有的地方都可以起作用
		局部变量：只能在自己的作用域当中起作用；
		
		全局变量可以被函数内部进行操作，但是全局当中没法操作局部变量；

			
		全局变量是可以在局部当中进行操作的；当局部里面有一个变量没有写var的时候：************************************************
			1、看看这个变量是不是形参，如果是形参，当作局部变量处理
			2、如果这个变量没有带var,同时形参也没有这个变量，接下来看看全局当中是否有这个变量，有就是操作全局变量的值；
			 如果没有这个全局变量，相当于是函数内部和外部都没有定义过这个变量，此时就是在定义一个全局变量；


	3)      作用域链
			描述的是变量查找的规则；先从自己的作用域当中去查找，找到就输出，找不到会继续往上级去查找，一直找到全局为止；
		中间如果首先找到就会输出，不再继续，如果没有找到继续往上找，直到找到全局都没有，报错（这个变量未定义）！这个查找变量的规则，		过程被称作作用域链；

		作用域链是在函数调用的时候才会有的，定义的时候不存在
		每个执行环境都会有自己独立的作用域链





	4)	案例:
	面试题
		var num = 10;
		function fun() {
  			var num = 20;

  			fun2();
		}


		function fun2() {
  			console.log(num);//
		}


		fun();



特别专题（相当重要）：内存堆栈，整个程序执行的过程，函数的调用过程

		内存当中有两个重要的结构：栈和堆
		栈：栈结构先进后出（FILO） 可以想象成一个桶    栈结构当中开辟的内存，比较小，速度比较快，操作系统自动分配自动回收；
		堆：堆结构是链表结构，可以随意的在任何位置添加和删除；可以想象成一个链条；   堆结构当中开辟的内存，比较大，速度比较慢，
		一般都是由程序员自己用的时候再去申请分配；要想让内存回收，必须手动释放回收；

		在js当中，我们的内存回收几乎都是计算机自动回收；因为js里面封装了垃圾回收机制；



		程序开始执行到结束都做了什么：
			1、程序一开始执行，碰见了全局环境，首先会创建全局环境并且进行压栈，全局代码执行的时候依赖的就是全局环境当中的东西；
			比如 全局变量（全局变量如果存的是基本数据类型，那么这个值是直接存在栈当中的，如果这个变量存的是对象类型（函数、数组			）），那么函数和数组是要在堆结构当中开辟自己的空间专门存储的。然后把堆里面这块空间的地址存给栈当中的对应变量；


			2、当程序执行碰到了函数调用；函数是比较特殊，因为它也可以执行；函数执行的时候也要有自己的环境去依赖。因此函数执行也			是创建自己的函数环境进行压栈（函数环境一定是压在全局环境之上的），局部变量，是在函数环境当中存在的，只有函数执行，局			部变量才会出现。函数执行完成以后，函数环境要弹出栈（销毁归还内存）,局部变量也就不复存在了。


			3、当函数调用完成以后，会继续执行全局代码，一直到所有的代码都执行完成，代表程序执行结束，程序结束的时候，我们的全局			环境最后出栈。





第五节: 预解析 预解释  变量提升

		预解析：
			程序在执行之前会先进行预解析；
			预解析会解析带var的变量和函数
				解析函数优先级比解析变量要高：可以认为解析的时候分为两步，先去解析所有的函数，再去解析所有的带var变量；
				解析过程当中，如果函数重名，会覆盖（后面的函数会把前面的覆盖掉）
					      如果变量重名，会忽略；
				
				解析函数的时候，函数定义方式不同，解析过程也不大一样：
					如果是字面量定义，整个函数都要被提升
					如果是表达式定义，只会提升变量（当作带var变量去提升）；
					function func(){};
					var func = function(){};

				变量如果不带var，变量是不会进行预解析的；只有带var的变量才会进行预解析；
	
	
	
				



	a)	预解析演示
	b)	预解析效果, 作用
	c)	面试题:

	--------------------------------------------------------
	
	alert(a);    
	a = 0;
	
	--------------------------------------------------------

	alert(a);    
	var a = 0;
	alert(a);    

	--------------------------------------------------------

	alert(a);    
	var a = '我是变量';
	function a(){ alert('我是函数') }
	alert(a);    

	--------------------------------------------------------

	alert(a); 
	a++;
	alert(a);    
	var a = '我是变量';
	function a(){ alert('我是函数') }
	alert(a)   

	--------------------------------------------------------

	alert(a);   
	var a = 0;
	alert(a);   
	function fn(){
 		alert(a);    
 		var a = 1;
 		alert(a);    
	}
	fn()
	alert(a);    

	--------------------------------------------------------


	alert(a);    
	var a = 0;
	alert(a);    
	function fn(){
   		alert(a);    
   		a = 1;
   		alert(a);   
	}
	fn()
	alert(a);   

	--------------------------------------------------------
	alert(a);    
	var a = 0;
	alert(a);    
	function fn(){
		   alert(a);    
		   a = 1;
		   alert(a);   
	}
	fn()
			
	function fn(){
		alert(a)
		var a = 0;
		alert(a++);
	}
			
	alert(a); 

	-------------------------------------------------------







第六节: IIFE，回调函数   arguments 函数递归    

IIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，别名 匿名函数自调用表达式

也就是说，声明函数的同时立即调用这个函数。


			//函数表达式  
			//匿名函数自调用，立即调用的函数表达式
			(function(){
				console.log('i love you ! zhaoliying~');
			})();
		
			
			
			//特点：这样的函数只能执行一次
			//	      这样的函数不会发生预解析
			//	       定义的同时执行
			
			//作用：
				  //隐藏代码的实现，暴露到外面该暴露的东西
				  //防止外部命名空间被污染
				  //初始化一个项目的初始化项



Arguments  函数实参伪数组

	在js当中（es5）当中，函数形参可有可无；

	function(a,b){
		return a + b;
	}




函数递归


回调函数：函数是我定义的   我没有调用    最终执行了~
	事件
	定时器
	ajax
	生命周期回调函数




晚自习强化练习
	作业: 
		面试题: 函数，作用域，预解析（必须理解）
		


(function(w) {


})( window );	
