# 1.  必备技术栈概要

## 1.1. 原生JavaScript

\1.     面向对象：

 		a .**作用域(链)：**

​              任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。

1. 全局作用域（Global Scope）

　　在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：

　　（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：

```
var` `authorName=``"山边小溪"``;
function` `doSomething(){
  ``var` `blogName=``"梦想天空"``;
  ``function` `innerSay(){
    ``alert(blogName);
  ``}
  ``innerSay();
}
alert(authorName); ``//山边小溪
alert(blogName); ``//脚本错误
doSomething(); ``//梦想天空
innerSay() ``//脚本错误
```

​        （2）所有未定义直接赋值的变量自动声明为拥有全局作用域，例如：

```
function` `doSomething(){
  ``var` `authorName=``"山边小溪"``;
  ``blogName=``"梦想天空"``;
  ``alert(authorName);
}
doSomething(); ``//山边小溪
alert(blogName); ``//梦想天空
alert(authorName); ``//脚本错误
```

变量blogName拥有全局作用域，而authorName在函数外部无法访问到。

　　（3）所有window对象的属性拥有全局作用域

　　一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。

　　2.  局部作用域（Local Scope）　　

　　和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域，例如下列代码中的blogName和函数innerSay都只拥有局部作用域。

```
function` `doSomething(){
  ``var` `blogName=``"梦想天空"``;
  ``function` `innerSay(){
    ``alert(blogName);
  ``}
  ``innerSay();
}
alert(blogName); ``//脚本错误
innerSay(); ``//脚本错误
```

2.**作用域链**: 标识符所在的位置越深,读写速度就会越慢;
因为全局变量总是存在于运行期上下文作用域链的最末端;
如果一个跨作用域的对象被引用一次以上,则先把它存储到局部变量里面再使用.

3.**作用域链**: 是描述路径的术语,沿着该路径可以确定变量的值;当a =0时,因为
没有使用var关键字,因此赋值操作会沿着作用域链到上一级(父级)var a= 4;并改变其值;




b.原型(链):

**一.什么是__proto__(原型):**

　　**每个对象**都有__proto__属性 , __proto__指向创建他的构造函数的原型对象(**实例指向原型对象的指针**).

**二.什么是prototype(原型对象):**

　　**每个函数**都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用（使用new操作符调用）的时候，新创建的对象会从原型对象上继承属性和方法。原型是一个**对象**，其他对象可以通过它实现继承。

　　**作用**:主要用来**继承**,实现继承靠的是原型链

　　　　 如果构造函数和构造函数的原型对象都有同一个方法 , 那么对优先继承构造函数的 , 在js底层 , 一般都是给父构造函数的原型对象添加方法 .

**原型链总结:**

　　1.继承的实现并不是靠prototype,而是靠__proto__
　　2.原型链的作用,在于读取对象的某个属性时,js引擎会优先查找对象本身的属性,如果没有,会去该对象的构造函数的原型对象(prototype)上面找,一直找到最顶层的原型对象,Object.prototype , 如果还没有则返回undefine
　　3.这个过程中,维持上下层关系靠的是__proto__

c.闭包:

- 闭包的概念:函数A中,有一个函数B,函数B中可以访问函数A中定义的变量或者是数据,此时形成了闭包(这句话暂时不严谨
- 闭包的模式:函数模式的闭包,对象模式的闭包
- 闭包的作用:缓存数据,延长作用域链
- 闭包的优点和缺点:缓存数据

d.执行上下文(栈):

> 执行上下文(Execution Context):函数执行前进行的准备工作(也称执行上下文环境)。
> 运行JavaScript代码时,当代码执行进入一个环境时,就会为该环境创建一个执行上下文,它在运行代码前做一些准备工作,比如说：确定作用域,创建局部变量对象等。
> ####JavaScript中执行环境
> 1：全局环境
> 2：函数环境
> 3：eval函数环境(已经被淘汰)
> ####相对应的执行上下文类型同样也有三种
> 1：全局执行上下文
> 2：函数执行上下文
> eval函数执行上下文
>

JavaScript运行时首先会进入全局环境,对应会生成全局上下文。程序代码中基本都会存在函数,那么调用函数，就会进入函数执行环境,对应就会产生该函数的执行上下文。

因为JavaScript是单线程,所以同一个时间段只能做一件任务,完成之后才可以继续下一个任务,所以就必须有一个排队机制。

####JavaScript 中管理多个执行上下文
函数编程中,代码中会声明多个函数,对应的执行上下文也会存在多个。在JavaScript中，通过栈的存取方式来管理执行上下文，我们可称其为执行栈
，或函数调用栈(Call Stack)。

####**栈数据结构**

栈遵循"先进后出，后进先出"的规则,或称LIFO(“Last in First Out”)的规则。
栈数据结构的特点：
1：后进先出，先进后出
2：出口在顶部，且仅有一个

**执行栈(函数调用栈)**
JavaScript中如何通过栈来管理多个执行上下文。

程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中(入栈)。程序执行完成时，它的执行上下文就会被摧毁，并从栈顶被推出(出栈)，控制权交由下一个执行上下文。

因为 JavaScript 执行中最先进入全局环境，所以处于"栈底的永远是全局环境的执行上下文"。而处于"栈顶的是当前正在执行上下文"，当函数调用完成后，它就会从栈顶被推出(通常情况下，闭包会阻止该操作)。

全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后才会从执行栈中被推出，否则一直存在于栈底。至于函数上下文的个数是没有任何限制的，每到调用执行一个函数时，引擎就会自动新建出一个函数上下文。


e.继承:

\2.     操作DOM

​			1.动态创建元素:document.createElement("div")

​            2.appendChild：像容器的末尾添加一个子元素

​            3.removeChild():删除容器中的子节点 父节点.removeChild(子节点)

​			4.replaceChild()替换子节点

5. insertBefore :在父节点中的某个子节点的前面插入新元素；
6. getAttribute(“属性名”) : 获取行间属性名对应的属性值；如果行间属性名不存在，那么得到结果是null;
7. setAttribute : 设置行间属性所对应的属性值 setAttribute(属性名，属性值)
8. removeAttribute("属性名"): 删除行间属性

## 1.2. H5，C3新特性

\1.     语义化标签

```
header、footer、aside、section、article、nav
```

\2.     本地存储

- localStorage - 没有时间限制的数据存储
- sessionStorage - 针对一个 session 的数据存储

\3.     Canvas，audio，video

\4.     C3新增选择器

## 1.3. 移动端

\1.     移动端适配

\2.     移动端常见问题：

1物理像素边框:是指设置边框 为`1px` **css**像素，在 **普通屏幕** 下`1px`，**高清屏幕** (`dpr`为`2`)下`2px`的情况。是由于不同移动设备的`dpr`不同，导致`1px` **css**像素，转换成物理像素后显示不一样。

**事件点透**:

​       **是指两个元素其中一个元素具有默认的点击事件，当我们让不具有点击事件的元素隐藏起来，会触发另一个元素的点击事件，这种行为被称之为点透事件。**

> **分析这种点透事件的原因，我们需要了解移动端和PC端的事件的不同之处：**
>
> **1、PC端所有的事件都能够在移动端被触发.**也就是说索然移动端目前主要是touch事件，但是其他的事件也会被触发，只是没有相对应的事件处理函数，比如touchstart就触发了click事件。
>
> **2、PC端事件在移动端触发有300毫秒延迟，**这是因为PC端的事件太多，可能同一个行为能够触发非常多的事件，浏览器需要通过这300毫秒内的行为，判断究竟触发的是哪个事件。比如点击一下，触发的事件可能有点击事件，鼠标按下事件，双击事件等。浏览器需要根据就下来你的操作来判断究竟属于哪个事件，如果接下来你不进行操作那么就是点击事件，如果你连续点击了，那么可能是双击事件。

**点透事件的解决办法：取消元素的默认点击事件**,还要设置新的跳转行为。



**多指操作**：

## 移动端触摸事件（基础事件）

- touchstart--- 触摸开始
- touchmove--- 触摸移动
- touchend--- 触摸结束
- touchcancel--- 触摸中断（在触摸过程中被打断，如弹框）

```
box.addEventListener('touchmove',function (event) {
    console.log('触摸移动');
}
```

#### touchEvent对象

- touches---触发事件时屏幕上的触点个数
- targetTouches---触发事件时事件元素上的触点个数
- changedTouches---触发事件发生改变的触点个数
- target ---事件元素
- stopPropagation() ---阻止事件冒泡
- preventDefault() ---阻止默认行为

#### touchlist对象

touchEvent对象的集合，类数组对象;
targetTouches、touches、changedTouches属性返回的都是touchlist对象

#### touch对象

- clientX/clientY---触点在视口上的位置
- pageX/pageY---触点在页面上的位置
- screenX/screenY---触点在屏幕上的位置

```
 box.addEventListener('touchstart',function (event) {
    console.log(event.touches);  //一个手指触摸时输出   Touchlist{0:Touch,length:1}
    var startX = event.touches[0].clientX; //触点在视口上的位置
 }
```

## 手势事件

### IOS的手势事件

#### 1.1 事件

- gesturestart---手势开始，手指触碰当前元素，屏幕上有两个或者两个以上的手指
- gesturechange---手势变化，手指触碰当前元素，屏幕上有两个或者两个以上的手指位置在发生移动
- gestureend---手势结束，在gesturestart后, 屏幕上只剩下两根以下（不包括两根）的手指

#### 1.2 touchEvent 新增的属性

- scale 触点的距离与触点初始距离的比例
- rotation 触点的角度差与初始角度差的差

```
 box.addEventListener('gesturechange', function(event){
    box.innerHTML = 'rotation : '+event.rotation + '<br>';
    box.innerHTML += 'scale : '+event.scale + '<br>';
 });
```

### 移动端手势事件（多指事件）

```
//封装 gestrue.js插件
(function (w) {
    /**
     * 用于给元素监听手势事件
     * @param node  要监听的元素
     * @param callback 对象，对象有三个函数 start、change、end
     */
    function gesture(node, callback) {
        //手势开始
        // 当开始触摸元素的时候，判断屏幕上手指个数 >= 2
        node.addEventListener('touchstart', function(event) {
            if (event.touches.length >= 2) {
                //标记已经触发了手势开始
                node.isGestureStart = true;
                //计算一下两个触点的初始距离
                this.startDst = getDst(event.touches[0], event.touches[1]);
                //计算一下两个触点的初始角度
                this.startDeg = getDeg(event.touches[0], event.touches[1]);
                // 调用回调函数
                if (callback && typeof(callback['start']) === 'function') {
                    callback['start']();
                }
            }
        });

        // 手势移动
        // 当有手指移动的时候，判断屏幕上手指的个数 >= 2
        node.addEventListener('touchmove', function(event) {
            if (event.touches.length >= 2) {
                // 计算当前两个触点的距离
                var currentDst = getDst(event.touches[0], event.touches[1]);
                // 计算书两个触点的当前的夹角角度
                var currentDeg = getDeg(event.touches[0], event.touches[1]);
                // 计算当前两个触点的距离 和 两个触点的初始距离 比例
                event.scale = currentDst / this.startDst;
                // 计算两个触点，夹角的变化
                event.rotation = currentDeg - this.startDeg;
                //调用回调函数
                if (callback && typeof(callback['change']) === 'function') {
                    callback['change'](event);
                }
            }
        });

        // 手势结束
        // 触发过手势开始并且有触摸结束的时候判断屏幕上手指数量 < 2
        node.addEventListener('touchend', function(event) {
            if (node.isGestureStart && event.touches.length < 2) {
                //重置标记
                node.isGestureStart = false;
                //调用回调函数
                if (callback && typeof(callback['end']) === 'function') {
                    callback['end']();
                }
            }
        });

        /**
         * 计算两个触点的位置
         * @param touch1 第一个触点
         * @param touch2 第二个触点
         */
        function getDst(touch1, touch2) {
            //计算两个直角边的长度
            var x = touch2.clientX - touch1.clientX; //水平方向的距离
            var y = touch2.clientY - touch1.clientY; //垂直方向的距离
```



## 1.4. ES6+

**\1.     a.箭头函数:**

> 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连`{ ... }`和`return`都省略掉了。还有一种可以包含多条语句，这时候就不能省略`{ ... }`和`return`：
>
> 如果参数不是一个，就需要用括号`()`括起来：
>
> ### this
>
> 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的`this`是词法作用域，由上下文确定。
>
> 箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`：
>
> 由于`this`在箭头函数中已经按照词法作用域绑定了，所以，用`call()`或者`apply()`调用箭头函数时，无法对`this`进行绑定，即传入的第一个参数被忽略：

​         **b.promise:**

> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
>
> `Promise`对象有以下两个特点。
>
> （1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
>
> （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
>
> 注意，为了行文方便，本章后面的`resolved`统一只指`fulfilled`状态，不包含`rejected`状态。
>
> 有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。
>
> `Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
>
> 如果某些事件不断地反复发生，一般来说，使用 [Stream](https://nodejs.org/api/stream.html) 模式是比部署`Promise`更好的选择。

​        **c.async/await:**

> `async`函数对 Generator 函数的改进，体现在以下四点。
>
> （1）内置执行器。
>
> Generator 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。
>
> ```javascript
> asyncReadFile();
> ```
>
> 上面的代码调用了`asyncReadFile`函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。
>
> （2）更好的语义。
>
> `async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。
>
> （3）更广的适用性。
>
> `co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象，而`async`函数的`await`命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
>
> （4）返回值是 Promise。
>
> `async`函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用`then`方法指定下一步的操作。
>
> 进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。

​        d.class:

### constructor 方法

`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。

### 取值函数（getter）和存值函数（setter）

与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

### **注意点**

**（1）严格模式**

类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。

**（2）不存在提升**

类不存在变量提升（hoist），这一点与 ES5 完全不同。

**（3）name 属性**

由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被`Class`继承，包括`name`属性。

**（4）Generator 方法**

如果某个方法之前加上星号（`*`），就表示该方法是一个 Generator 函数。

**（5）this 的指向**

类的方法内部如果含有`this`，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。

## 2静态方法 [§](https://es6.ruanyifeng.com/#docs/class#静态方法) [⇧](https://es6.ruanyifeng.com/#docs/class)

类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

\2.     加分项: promise深入使用与自定义实现

## 1.5. 模块化

\1.     ES6

\2.     Commonjs

## 1.6. 构建工具

\1.     Webpack核心思想：模块化打包

\2.     Webpack基本配置: entry, output, module&rules, plugins, devServer, devtool, resolve

\3.     打包各种资源: JS / CSS/img/html/...

\4.     加分项: 自定义webpack打包环境, Webpack性能优化

## 1.7. 前后台交互

\1.     原生ajax请求 xhr/fetch

\2.     ajax请求跨域问题

\3.     ajax请求库axios的理解和使用

\4.     axios的二次封装

\5.     加分项: axios的核心实现源码分析

## 1.8. 框架

\1.     jQuery

(1)   整体理解

(2)   jQuery核心函数

(3)   jQuery核心对象

\2.     Vue

(1)   Vue基本核心语法

(2)   Vue-router

(3)   Vuex

(4)   MVVM实现原理

\3.     React

(1)   React基本核心语法

(2)   React-router

(3)   Redux

# 2.  JS异步编程

## 2.1. 前置知识

\1.     JS语言的执行环境是"单线程", 也就是我们写的所有js代码都是在一个线程(主线程)上执行

\2.     理解单线程: 

(1)   就是指一次只能完成一件任务。

(2)   如果有多个任务，就必须排队，前一个任务完成，再执行后面一个任务，以此类推

\3.     js执行任务的2种模式

(1)   同步（Synchronous）

①   后一个任务等待前一个任务结束，然后再执行，

②   程序的执行顺序与任务的排列顺序是一致的、同步的

(2)   异步（Asynchronous）

①   每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，

②   后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

\4.     为什么需要异步JS?

(1)   浏览器端: 

①   耗时很长的操作都应该异步执行，避免浏览器失去响应

②   给时机让浏览器能去更新界面, 响应用户操作

(2)   Node端:

①   "异步模式"是唯一的模式，执行环境是单线程的

②   处理请求的回调函数/数据库操作/文件读写操作都必须是异步处理, 否则处理多个请求时很快就会失去响应

\5.     JS常用的异步编码方式

(1)   回调函数

(2)   事件机制

(3)   消息订阅与发布 / 全局事件总线

(4)   Promise

(5)   async & await

## 2.2. 回调函数

\1.     异步编程最基本的方法, 所有模式都是在此基础上进行封装扩展而来

\2.     回调函数的执行模式:

(1)   异步执行

(2)   同步执行

\3.     异步回调的缺点: 

(1)   不利于代码的阅读和维护，各个部分之间高度耦合。

(2)   容易导致回调地狱问题

## 2.3. 事件监听

\1.     事件驱动模式: 

(1)   任务的执行不取决于代码定义的顺序，而取决于某个事件是否发生

(2)   事件监听函数定义时不会执行, 只有当事件发生(分发事件)后才执行

\2.     分类:

(1)   原生DOM事件

(2)   自定义事件

\3.     操作:

(1)   在某个元素/组件对象上绑定特定事件监听

(2)   在某个元素/组件对象上分发事件

\4.     特点:

(1)   针对某个DOM元素绑定监听和分发事件

(2)   针对某个组件对象绑定监听和分发事件

## 2.4. 消息订阅/发布与全局事件总线

\1.     消息订阅/发布:

订阅全局消息

发布全局消息

\2.     全局事件总线:

绑定事件监听

分发事件

\3.     特点:

分发事件后, 所有同名的事件监听回调都会调用

## 2.5. Promise

\1.     实现异步编程新的通用解决方案

\2.     相对于纯回调的优势

(1)   指定异步回调函数的方式更灵活(可以在启动异步任务后,甚至可以在任务完成后)

(2)   通过then的链式调用解决回调地狱的问题

\3.     不足: 还需要指定回调函数

## 2.6. async/await

\1.     基于promise的语法糖, 简化了promise对象的使用(不再使用回调函数编码)

\2.     以同步编码方式实现的异步流程

\3.     是js异步编程的终极解决方案(基本上可以这样说)

## 2.7. JS事件循环机制

\1.     js是单线程运行的

\2.     js的回调函数可以异步执行, 也可以同步执行

\3.     js通过event-loop机制实现了js的单线程异步执行

(1)   JS引擎解析执行js代码总是在主线程执行(WebWorks除外)

(2)   浏览器有在分线程执行的对应管理模块(浏览器是多线程执行的)

①   定时器

②   DOM事件监听

③   ajax请求

④   Promise

⑤   MutationObserver

(3)   JS引擎有专门的回调队列, 缓存待执行的回调函数

①   宏队列

②   微队列

## 2.8. Promise深入理解

\1.     如何改变promise的状态?

\2.     一个promise指定多个成功/失败回调函数, 都会调用吗?

\3.     promise.then()返回的新promise的结果状态由什么决定?

(1)   返回一个非promise值 resolved 

(2)   抛出异常 rejected

(3)   返回一个promise

①   成功了 resolved

②   失败了 rejected

③   pending pending

\4.     改变promise状态和指定回调函数谁先谁后?

\5.     promise如何串连多个操作任务?

\6.     promise异常传(穿)透?

\7.     中断promise链

## 2.9. 自定义Promise

\1.     定义整体结构

\2.     Promise构造函数的实现

\3.     promise.then()/catch()的实现

\4.     Promise.resolve()/reject()的实现

\5.     Promise.all/race()的实现

\6.     Promise.resolveDelay()/rejectDelay()的实现

\7.     ES6 class版本

# 3.  前后台交互

## 3.1. 接口的理解/测试/模拟

\1.     前后台交互接口: 请求地址 / 请求方式 / 请求参数格式 / 响应数据格式

\2.     测试接口: 使用postman

\3.     模拟(mock)接口: 使用mockjs / json-server / webpack / node&express

## 3.2. ajax请求

\1.     区别ajax请求与一般的HTTP请求

\2.     原生ajax请求: XHR与fetch

\3.     XHR的基本编码流程

## 3.3. 解决ajax跨域问题的常见技巧

\1.     JSONP： json with padding（垫子）

\2.     CORS: 服务器端设置响应头： Access-Control-Allow-Origin: www.taobao.com

\3.     代理

 

## 3.4. axios的理解和使用

### 3.4.1. axios的特点

(1)   基于xhr/http包 + promise的异步ajax请求库

(2)   浏览器端/node端都可以使用

(3)   支持请求／响应拦截器

(4)   支持请求取消

(5)   请求/响应数据转换

(6)   批量发送多个请求

### 3.4.2. axios的常用语法

axios(config): 通用/最本质的发任意类型请求的方式

axios(url[, config]): 可以只指定url发get请求

axios.request(config): 等同于axios(config)

axios.get(url[, config]): 发get请求

axios.delete(url[, config]): 发delete请求

axios.post(url[, data, config]): 发post请求

axios.put(url[, data, config]): 发put请求

 

axios.create([config]): 创建一个新的axios(它没有下面的功能)

 

axios.defaults.xxx: 请求的默认全局配置

 

axios.interceptors.request.use(): 添加请求拦截器

axios.interceptors.response.use(): 添加响应拦截器

 

axios.Cancel(): 用于创建取消请求的错误对象

axios.CancelToken(): 用于创建取消请求的token对象

axios.isCancel(): 是否是一个取消请求的错误

 

axios.all(promises): 用于批量执行多个异步请求

axios.spread(): 用来指定接收所有成功数据的回调函数的方法

## 3.5. axios的二次封装

\1.     请求loading

\2.     token处理: 通过请求头携带token数据, 对token进行校验处理

\3.     异步请求成功的数据不是response, 而是response.data

\4.     统一处理请求异常

\5.     对请求体参数进行urlencode处理, 而不使用默认的json方式(后台接口不支持)

## 3.6. axios的核心实现分析

### 3.6.1. instance与axios的区别?

\1.    相同: 

(1)   都是一个能发任意请求的函数: request(config)

(2)   都有发特定请求的各种方法: get()/post()/put()/delete()

(3)   都有默认配置和拦截器的属性: defaults/interceptors

\2.    不同:

(1)   默认配置不一样, 且相互之间是独立的

(2)   instance没有axios后面添加的一些方法: create()/CancelToken()/all()

 

### 3.6.2. axios运行的整体流程?

​                 ![image-20200411220150366](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411220150366.png)              

### 3.6.3. axios的请求/响应拦截器是什么?

 ![image-20200411220209827](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411220209827.png)

\1.    请求拦截器: 

在真正发送请求前执行的回调函数

可以对请求进行检查或配置进行特定处理

成功的回调函数, 传递的默认是config(也必须是)

失败的回调函数, 传递的默认是error

 

\2.    响应拦截器

在请求得到响应后执行的回调函数

可以对响应数据进行特定处理

成功的回调函数, 传递的默认是response

失败的回调函数, 传递的默认是error

### 3.6.4. axios的请求/响应数据转换器是什么?

\1.    请求转换器: 对请求头和请求体数据进行特定处理的函数

if (utils.isObject(data)) {

  setContentTypeIfUnset(headers, 'application/json;charset=utf-8');

  return JSON.stringify(data);

}

\2.    响应转换器: 将响应体json字符串解析为js对象或数组的函数

response.data = JSON.parse(response.data)

 

# 4.  Webpack打包项目

## 4.1. webpack的理解

\1.    本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具

\2.    当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。

## 4.2. webpack的几个核心概念

\1.    **入口****(entry)**: 打包依赖图的入口js

\2.    **输出****(output)**: 打包生成的bundle 

\3.    **loader**: webpack 只能理解 JS 和 JSON 文件, loader打包其它类型模块

\4.    **插件****(plugin)**: 用来处理各种各样的任务(webpack和loader处理不了)

\5.    **模式****(mode)**: 用于启用 webpack 内置的系列配置

\6.    **浏览器兼容性****(browser compatibility)**: 通过加载polyfill来兼容低版本浏览器

## 4.3. webpack常用一级配置

\1.    entry

\2.    output

\3.    module & rules

\4.    plugins

\5.    mode

\6.    devServer

\7.    devtool

\8.    resolve

\9.    externals

\10.  optimization

 

## 4.4. 说说几个常见的loader

\1.    babel-loader

\2.    css-loader/style-loader/less-loader/stylus-loader/ sass-loader/postcss-loader

\3.    file-loader / url-loader

\4.    eslint-loader

\5.     vue-loader/vue-style-loader

## 4.5. 说说几个常见的plugin

\1.    html-webpack-plugin

\2.    clean-webpack-plugin

\3.    mini-css-extract-plugin

\4.    optimize-css-assets-webpack-plugin

\5.    copy-webpack-plugin

\6.    webpack-bundle-analyzer

\7.    webpack.ProgressPlugin

\8.    webpack.HotModuleReplacementPlugin

 

## 4.6. 区别plugin与loader

\1.    loader: 用于加载特定类型的资源文件, webpack本身只能打包js, 如果打包css就需要css-loader/style-loader, 如果打包图片就需要file-loader/url-loader

\2.    plugin: 用来扩展webpack其它方面的功能, 如页面引入打包文件需要html-webpack-plugin, 删除文件需要clean-webpack-plugin

## 4.7. 区别module，chunk 和 bundle ?

 ![image-20200411221042721](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221042721.png)

\1.    module: 我们手写下一个一个的文件

\2.    webpack开始打包后, 会根据文件引用关系生成内存中的几个 chunk 文件

\3.    保存到本地的是bundle文件, 一般一个chunk对应一个bundle, 但也可能一个chunk对应多个bundle(拆分样式打包)

\4.    拆分js是在生成chunk前, 所以拆分出的js都是一个单独的chunk

\5.    拆分css是在生成chunk后, 所以拆分出的css与js共用一个chunk

 

## 4.8. 区别webpackPrefetch与webpackPreload

webpack4添加的魔法注释功能, 可以使用preload-webpack-plugin@next进行处理

\1.    webpackPreload: 

(1)   同时并行请求加载, 针对当前就需要的bundle文件

(2)   <link href=’’ rel=preload>

\2.    webpackPrefetch: 

(1)   空闲时才请求加载, 针对其它路由需要的bundle文件 

(2)   <link href=’’ rel=prefectch>

 

## 4.9. 区别hash、chunkhash、contenthash

\1.    理解

(1)   hash整体打包内容的md5值

(2)   chunkhash当前chunk内容的md5值

(3)   contenthash当前bundle内容的md5值

\2.    使用

(1)   js/css/img使用contenthash

(2)   img/audio/video使用hash时本质还是用的contenthash

**3.**    **注意**

**用hash****有什么问题?**

**用chunkhash****有什么问题?**

## 4.10. 区别source-map 中inline与eval, cheap与module

\1.    Inline

(1)   生成全部的source map后整体内联到打包文件中

(2)   更新代码时完全重新生成source map

\2.    eval

(1)   以模块为单位生成source map内联到打包文件中

(2)   更新代码时只会重新生成相应的source map

(3)   主要是更新打包速度快于inline

\3.    cheap

(1)   只记录代码行号, 不记录列号

(2)   只映射自定义模块

\4.    module

(1)   只记录代码行号, 不记录列号

(2)   只映射第三方模块

**最佳实践****:**

**开发环境****------devtool: 'cheap-module-eval-source-map'**

**测试生产环境****-----devtool: 'cheap-module-source-map'**

**上线生产环境****-----devtool: 'none'**

 

## 4.11. 说说webpack中babel的使用

\1.     使用@babel/core和@babel/preset-env

(1)   只能编译ES6的新语法(转换为ES5相应的语法)

(2)   问题: 不能处理ES6的新API, 在相对低版本浏览器中不能运行

\2.     使用@babel/polyfill

(1)   内部通过core-js提供了新API的实现

(2)   问题: 默认是打包整体包, 导致打包文件太大

\3.     实现polyfill的按需要引入打包

(1)   useBuiltIns: 'usage'

(2)   问题: polyfill辅助函数是在每个模块中内置定义的, 很可能重复定义了

\4.     使用@babel/plugin-transform-runtime

(1)   引入单独helpers定义的辅助函数, 不再产生重复定义的多余代码

(2)   减小打包文件

## 4.12. webpack如何优化打包文件

\1.     目标

兼容性 / 减小打包文件/ 懒加载 / 预加载 / 首屏加载优化

\2.     常用技巧

(1)   兼容低版本浏览器

(2)   拆分打包 & 压缩

(3)   异步/懒加载

(4)   预取/预加载

(5)   打包文件hash化(利用浏览缓存)

(6)   Tree Shaking

(7)   Scope Hoisting(作用域提升)

(8)   服务器(nginx)开启gzip

(9)   打包文件分析

## 4.13. webpack如何优化打包

\3.     目标

加快打包 / 提升开发调试体验

\4.     常用技巧

(1)   loader增加include匹配特定条件

(2)   合理配置extensions扩展名

(3)   配置resolve.alias字段, 指定常用的路径别名

(4)   dll第三方模块进行预打包==> 使HardSourceWebpackPlugin更简洁更快

(5)   eslint代码规范检查

(6)   sourcemap 源码映射

(7)   live-reload / hot-reload

(8)   加快loader处理: 多线程/多进程loader

 

# 5.  手写代码(工具函数库)

https://github.com/zxfjd3g/atguigu-utils

## 5.1. 函数相关

### 5.1.1. 函数对象的call() / apply() / bind()

### 5.1.2. 函数的节流(throttle)与防抖(debounce)

## 5.2. 数组相关

### 5.2.1. 数组声明式系列方法

### 5.2.2. 数组去重(unique)

### 5.2.3. 数组合并(concat)与切片(slice)

### 5.2.4. 数组扁平化(flatten) 

### 5.2.5. 数组取真与分块

### 5.2.6. 数组取差异与合并

### 5.2.7. 删除数组中部分元素

### 5.2.8. 得到数组的部分元素

 

 

## 5.3. 对象相关

### 5.3.1. 自定义new和instanceof工具函数

### 5.3.2. 合并多个对象

### 5.3.3. 对象/数组浅拷贝与深拷贝

## 5.4. 字符串相关

### 5.4.1. 字符串倒序

### 5.4.2. 字符串是否是回文

### 5.4.3. 截取字符串

## 5.5. 事件总线

### 5.5.1. EventBus: 包含所有功能的全局事件总线对象

### 5.5.2. EventBus.on(eventName, listener): 绑定事件监听

### 5.5.3. EventBus.emit(eventName, data): 分发事件

### 5.5.4. EventBus.off(eventName): 解绑事件监听

## 5.6. 消息订阅与发布

### 5.6.1. PubSub: 包含所有功能的订阅/发布消息的管理者

### 5.6.2. PubSub.subscribe(msg, subscriber): 订阅消息  

### 5.6.3. PubSub.publish(msg, data): 异步发布消息

### 5.6.4. PubSub.publishSync(msg, data): 同步发布消息

### 5.6.5. PubSub.unsubscribe(flag): 取消订阅

## 5.7. Promise

### 5.7.1. 定义整体结构

### 5.7.2. Promise构造函数的实现

### 5.7.3. promise.then()/catch()的实现

### 5.7.4. Promise.resolve()/reject()的实现

### 5.7.5. Promise.all/race()的实现

### 5.7.6. Promise.resolveDelay()/rejectDelay()的实现

## 5.8. ajax函数封装: axios

 

## 5.9. 数据结构与排序算法

### 5.9.1. 自定义栈: Stack

### 5.9.2. 自定义队列: Queue

### 5.9.3. 自定义优先级队列: PriorityQueue

### 5.9.4. 简单排序: 冒泡 / 选择 / 插入

### 5.9.5. 高级排序: 希尔

# 6.  原理结构图分析

## 6.1. 原型与原型链

```
function Foo () {}*

*const f1 = new Foo()*

*const f2 = new Foo()*

*const o1 = new Object()*

*const o2 = {}*

 
```

![image-20200411221303012](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221303012.png)

## 6.2. JS事件循环(Event Loop)机制

 ![image-20200411221313218](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221313218.png)

## 6.3. redux结构图

 ![image-20200411221324054](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221324054.png)

## 6.4. vuex结构图

 ![image-20200411221334809](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221334809.png)

## 6.5. Vue的数据绑定原理图

 ![image-20200411221346126](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221346126.png)

# 7.  框架必备技能

## Vue框架

## 7.1. 区别单向数据流与双向数据绑定

\1. 单向数据流

 ![image-20200411221358808](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221358808.png)

用户操作界面, 调用更新状态数据的方法, 一旦状态数据变化, 自动更新相应的界面

\2. 双向数据绑定

在原在的基础上, 通过v-model自动给表单项输入绑定监听, 将输入数据不通过action直接保存到state中

## 7.2. 生命周期函数

\1. vue的生命周期: 创建=>挂载=>更新=>销毁

\2. vue的生命周期勾子:

> (1)   初始化(一次): beforeCreate() => created() => beforeMount() => mounted()
>
> (2)   更新(n次): beforeUpdate() => updated()
>
> (3)   销毁(一次): beforeDestroy() => destroyed()
>
> (4)   组件缓存/激活: deactivated() / activated()
>
> (5)   捕获子组件错误: errorCaptured()

\3. 一些细节

> (1)   beforeCreate(): 在实例初始化之后立即同步调用，此时还没有数据代理和数据观察, 还不能通过this操作data中的数据
>
> (2)   created(): 可以通过this读取或修改data中的数据, 已经完成数据观察
>
> (3)   beforeMount(): 模板已经在内存中编译, 但还没有挂载到页面上, 不能通过ref找到对应的标签对象
>
> (4)   mounted(): 页面已经初始显示, 可以通过ref找到对应的标签
>
> (5)   beforeUpdate(): 在数据更新之后, 界面更新前调用, 只能访问到原有的界面
>
> (6)   updated(): 在界面更新之后调用, 此时可以访问最新的界面
>
> (7)   beforeDestroy(): 实例销毁之前调用, 此时实例仍然完全可用。
>
> (8)   destroyed(): Vue 实例销毁后调用, 数据绑定/事件监听器都没了, 但dom结构还在
>
> (9)   deactivated():组件失活, 但没有死亡
>
> (10)  activated(): 组件激活, 被复用
>
> (11)  errorCaptured(): 用于捕获子组件的错误,return false可以阻止错误向上冒泡(传递)
>
>  

![image-20200411221517496](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221517496.png)

## 7.3. 组件通信方式

### 7.3.1. props

\1. 父子组件间通信的基本方式

\2. 属性值的2大类型: 

(1)   一般: 父组件-->子组件

(2)   函数: 子组件-->父组件

\3. 问题:

(1)   隔层组件间传递: 必须逐层传递(麻烦)

(2)   兄弟组件间: 必须借助父组件(麻烦)

### 7.3.2. vue自定义事件

   子组件与父组件的通信方式

  用来取代function props

  不适合隔层组件和兄弟组件间的通信

### 7.3.3. 基于vue自定义事件的事件总线

   适合于任何关系的组件间通信

   缺点: 管理不够集中

### 7.3.4. vuex

多组件共享状态(数据的管理)

  组件间的关系也没有限制

  功能比全局事件总线更强大, 更适用于vue项目

### 7.3.5. slot插槽

  通信是带数据的标签

  注意: 标签是在父组件中解析

## 7.4. 路由

### 7.4.1. 路由跳转

1)     创建路由器: new Router({ })

2)     注册路由: routes: [ {path:’路由路径’, component: ‘路由组件’} ]

3)     注册路由器: new Vue({router})

4)     路由链接: <router-link :to="{name: 'home', params: {id: 1}}">home</router-link>

5)     编程式路由跳转: router.push()/replace()/back()

6)     自动跳转的路由: { path: '/', redirect: '/home' }

### 7.4.2. 路由传参

**1). params:**     

```
{name: ‘xxx’, path: “/person/:id”, component: Person}

router.push(‘/person/3’)

router.push({name: ‘xxx’, params: {id: 3}})

this.$route.params.id
```

​      ![image-20200411221604139](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221604139.png)

**2). query:**

![image-20200411221628086](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221628086.png)

```
          **this.$router.push(‘/xxx?id=3’)** 
```

![image-20200411221646073](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221646073.png)

**小细节： params只能用name，query既可以指定name，也可以指定path**

>   <**router-link** **:to=****’**{**name**: **“Test1”**, **params**: {**id**: **“111”**}}**’**>test1</**router-link**>   **无法匹配路由**-->    *  <**router-link** **:to=****’**{**name**: **“Test2”**, **query**: {**id**: **“222”**}}**’**>test2</**router-link**>   <**router-link** **:to=****’{path:****“/hello/test2”,**  **query**: {**id**: **“222”**}**}’**>test2</**router-link**>  
> 
> 
>  

**3). meta:**

​        ![image-20200411221802772](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221802772.png)

![image-20200411221821538](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221821538.png)

**4). props:**

**布尔值模式****:** **解耦路由组件**

​     

 ![image-20200411221838184](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221838184.png)

 ![image-20200411221847166](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221847166.png)

**对象模式：****props****静态传参**

 ![image-20200411221859753](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221859753.png)

 ![image-20200411221908498](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221908498.png)

 ![image-20200411221919300](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221919300.png)

**函数模式****: props****根据不同的路由对象动态传参**

 ![image-20200411221932238](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411221932238.png)

**备注： 不管通过哪种props方式传参，记住在组件内部通过props声明接收**

## React框架

## 7.5. React核心思想

\1.     模块化，组件化

\2.     JSX语法

> a)     在js中直接写html
>
> b)    在html中可以写js，需要用{}包起来

\3.     组件的3个基本属性

> a)     state: 组件状态
>
> b)    props:  组件外部向组件内传递属性数据
>
> c)     refs: 标识组件对象或者真实dom对象

## 7.6. React生命周期函数

```
  componentWillMount() {    ***console\***.log(**'------componentWillMount**  **组件将要挂载****------'**);* *  }      componentDidMount() {    ***console\***.log(**'-----componentDidMount**  **组件已挂载完毕****--------'**);    *setTimeout*(() => {     **this**.setState({      **msg**: 123     })    }, 2000)   }   this.setState({})   shouldComponentUpdate(nextProps, nextState) {    ***console\***.log(**'----shouldComponentUpdate**  **组件是否应该更新****--------'**);    *//* *该生命周期函数必须返回一个布尔值，来决定是否更新或者不更新* *true:* *更新，**false:* *不更新 *   *//* *此生命周期函数的意义是用来做性能优化的，当传入的**props**，**state**和之前的没有变化或者不需要更新的时候，就**return  false    //* *这样就不会触发**React DOM diff**算法 *   ***console\***.log(nextProps,  nextState);    **return true **  }      componentWillReceiveProps(nextProps) {    ***console\***.log(**'----componentWillUpdate**  **组件接收新的****props****值** **--------'**);   }      componentWillUpdate() {    ***console\***.log(**'----componentWillUpdate**  **组件将要更新****-------'**);   }   componentDidUpdate() {    ***console\***.log(**'------componentDidUpdate**  **组件已更新完毕****--------'**);   }      componentWillUnmount() {    ***console\***.log(**'------componentWillUnmount**  **组件将要卸载****-------'**);   }      render () {    ***console\***.log(**'render** **渲染****'**);    **return** (     <**div**>      App组件。。。     </**div**>    );   }  
```

 ![image-20200411222039662](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222039662.png)

## 7.7. 组件通信

### 7.7.1. props

> \1.     父传子: 非函数属性
>
> \2.     子传父: 函数属性
>
> \3.     隔层组件或兄弟组件传递比较麻烦

### 7.7.2. 消息订阅与发布机制(pubsub)

> \1.     订阅消息: PubSub.subscribe(‘消息名称’, callback)
>
> \2.     发布消息: PubSub.publish(‘消息名称’, ‘发布数据’)

### 7.7.3. Redux

\1.     多用于中大型项目，组件嵌套层级较多，数据较为复杂的场景

\2.     何为 store

> (1)   store 是一个 javascript 对象，它保存了整个应用的 state。
>
> (2)   允许通过 getState() 访问 state
>
> (3)   通过 dispatch(action) 改变 state
>
> (4)   通过 subscribe(listener) 注册 listeners

\3.     何为 action

> (1)   action是一个纯 js对象，
>
> (2)   必须有一个 type 属性表明正在执行的 action 的类型, 还有一个携带数据的属性
>
> (3)   实质上，action 是将数据从应用程序发送到 store 的载体  

\4.     何为 reducer

是纯函数，该函数以先前的state和一个action作为参数，并返回新的state。

```
array.recuce((preTotal, item) => preTotal + item , 0)

function count (state={}, action) {

retrn newState

}
```



## 7.8. React路由

### 7.8.1. 路由跳转

> \1.     路由器:  HashRouter, BrowserRouter
>
> \2.     路由: <Route path='/home' component={Home}></Route>
>
> \3.     路由链接: <Link to='/home'> HOME</Link>
>
> \4.     路由重定向: <Redirect to='/home'/>
>
> \5.     编程式路由导航: this.props.history.push/replace('/home')
>
> \6.     路由精准匹配exact: 要求必须完全匹配指定的路由，默认进行的模糊匹配

### 7.8.2. 路由传参

**1.**     params传参 推荐使用

```
<**Link** **to****='/home/homeChild/1'**>home子路由  <**Route** **path****='/home/homeChild/:id'** **component****=**{HomeChild}>
```

 ![image-20200411222251224](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222251224.png)

\2.     query传参 (不方便, 不建议使用)

```
<**Link** **to****='/home/homeChild?id=1'**>home子路由  <**Route** **path****='/home/homeChild'** **component****=**{HomeChild}>
```

 ![image-20200411222303780](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222303780.png)

\3.     props传参

```
<**Link** **to****='/home/homeChild'**>home子路由  <**Route** **path****='/home/homeChild'** **render****=**{() => <**HomeChild** **id****=**{123}/>}>
```

 

 ![image-20200411222316642](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222316642.png)

## jQuery

## 7.9. 整体理解

\1.     jQuery是一个功能强大的函数库, 封装了以下功能

> (1)   DOM的CRUD
>
> (2)   DOM事件处理
>
> (3)   ajax请求
>
> (4)   各种小的工具函数

 

\2.     核心语法

> (1)   jQuery核心函数
>
> (2)   jQuery核心对象

 

\3.     特点:

> (1)   链式调用
>
> (2)   读写合一
>
> (3)   更好的浏览器兼容性

## 7.10. jQuery核心函数

\1.     是什么?

就是jquery库向外暴露的$和jQuery, 一般都用$

 

\2.     它有2种使用方式:

(1)   作为函数使用

(2)   作为对象使用

 

\3.     $作为函数使用

> (1)   参数为函数: 指定回调函数在页面加载完后执行
>
> (2)   参数是选择器字符串: 查找所有匹配的元素, 返回jQuery对象
>
> (3)   参数是标签格式字符串: 创建DOM对象, 返回jQuery对象
>
> (4)   参数是DOM元素: 返回包含此DOM元素的jQuery对象

 

\4.     $作为函数对象使用

> (1)   发送ajax请求的各种方法: $.ajax()/get()/post()/getJSON()
>
> (2)   一些工具方法: $.each(array)/type(data)

 

## 7.11. jQuery核心对象

\1.     2种情况产生的对象 (内部包含n个dom元素对象)

> (1)   执行$函数返回的对象
>
> (2)   调用jQuery核心对象的方法返回的对象

 

\2.     主要方法

> (1)   进行DOM进行增删改的方法
>
> (2)   对内部的DOM元素进行进一步过滤查找的方法
>
> (3)   进行事件处理的方法: 绑定监听/解绑监听/事件委派

## 7.12. 编码测试

```
  <**html** **lang=****"en"**>  <**head**>  <**meta** **charset=****"UTF-8"**>  <**meta** **name=****"viewport"** **content=****"width=device-width, initial-scale=1.0"**>  <**meta** **http-equiv=****"X-UA-Compatible"** **content=****"ie=edge"**>  <**title**>Document  <**script** **src=****"https://cdn.bootcss.com/jquery/1.11.3/jquery.js"**>  <**script**>   */\*     $**作为函数使用**      a.* *参数为函数**:* *指定回调函数在页面加载完后执行**      b.* *参数是选择器字符串**:* *查找所有匹配的元素**,* *返回**jQuery**对象**      c.* *参数是标签格式字符串**:* *创建**DOM**对象**,* *返回**jQuery**对象**      d.* *参数是**DOM**元素**:* *返回包含此**DOM**元素的**jQuery**对象**    \*/ *   $(() => {    *// 1.* *给**test1**添加点击监听**,* *提示按钮的文本内容 *    $(**'#btn1'**).click(**function** () {     alert($(**this**).html())     $(**this**).html(**'test1111'**)    })      *// 2.* *在页面的最后添加一个新的按钮 *    $(**'test'**)     .click(**function** (event) {      alert(event.**target**.**innerHTML**)     })     .appendTo(**'body'**)        */\*      $**作为函数对象使用**      a.* *发送**ajax**请求的各种方法**: $.ajax()/get()/post()/jsonp()      b.* *一些工具方法**: $.each(array)/type(data)     \*/ *    $.ajax({     **url**: **'https://api.github.com/search/repositories'**,     **type**: **'GET'**,     **data**: {      **q**: **'v'**,      **sort**: **'stars' **     },     success: (data) => {      **console**.log(data)     },     error: () => {      alert(**'****请求错误****'**)     }    })      **const** arr = [1, 3, 5]    $.each(arr, (index, value) => **console**.log(index, value))    **console**.log($.type(arr), $.type(arr[0]))        */\*      2**种情况产生的**jQuery**核心对象* *(**内部包含**n**个**dom**元素对象**)      a.* *执行**$**函数返回的对象**      b.* *调用**jQuery**核心对象的方法返回的对象**     \*/ *    **const** $lis = $(**'li'**)    **const** $firstLi = $lis.first()    **console**.log($firstLi.html())      */\*      jQuery**对象的主要方法**      a.* *进行**DOM**进行增删改的方法**      b.* *对内部的**DOM**元素进行进一步过滤查找的方法**      c.* *进行事件处理的方法**:* *绑定监听**/**解绑监听**/**事件委派**     \*/ *    $(**'#btn2'**).click(**function** () {     $(**'ul'**).find(**'****li****>****button****'**).not(**':first'**).click(**function** () {      $(**this**).parent().remove()     })    })      $(**'#btn3'**).click(**function** () {     $(**'XtestX'**).appendTo(**'ul'**)    })      $(**'#btn4'**).click(**function** () {     $(**'ul'**).delegate(**'li:not(:first)>button'**, **'click'**, **function** () {      $(**this**).parent().remove()     })    })      $(**'#btn5'**).click(**function** () {     $(**'#btn1'**).unbind(**'click'**)     $(**'ul'**).undelegate(**'click'**)    })   })      <**body**>  **需求**1:* *点击**test1**按钮**,* *提示按钮的文本内容    需求**2:* *在页面的最后添加一个新的按钮    需求**3:* *发送**ajax**请求**,* *提示请求结果    需求**4:* *遍历数组**,* *得到不同数据的类型 *  *--> *  <**button** **id=****"btn1"**>test1  <**ul**>   <**li**>    <**span**>A    <**button**>testA      <**li**>    <**span**>B    <**button**>testB      <**li**>    <**span**>C    <**button**>testC         **需求**5:* *给列表中所有按钮添加点击监听**,* *点击删除当前行    需求**6:* *在最后添加一行    需求**7:* *与需求**5**功能一样**,* *但使用事件委托    需求**8:* *解除**btn1**上的点击监听和列表的委托点击监听 *  *--> *  <**button** **id=****"btn2"**>给列表中所有button添加点击监听<**br**>  <**button** **id=****"btn3"**>向列表中添加一个列<**br**>  <**button** **id=****"btn4"**>给列表中所有button添加点击监听(使用事件委托)<**br**>  <**button** **id=****"btn5"**>解绑事件监听<**br**>    
```

## 小程序

## 7.13. 程序语法：

> \1.    没有DOM，一切基于组件化
>
> \2.    小程序四个重要的文件: *.wxml, *.wxss, *.js, *.json

## 7.14. 小程序发送请求

\1.    语法: wx.request()

\2.    注意点:

> a)     发送的都是https请求
>
> b)    一个域名下最多配置20个域名
>
> c)     能处理的最大并发量是10个

## 7.15. 小程序本地数据存储

\1.    语法: wx.setStorage, wx.getStorage, wx.setStorageSync, wx.getStorageSync

\2.    单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。

## 7.16. 小程序获取openID流程

> \1.     理解： openId是小程序用户的唯一标识，通常利用openId来验证小程序用户身份，做支付，账户管理等操作
>
> \2.     openId由腾讯服务器提供的，必须满足： code + appID + appSecret
>
> \3.     code是登录的临时凭证，通过wx.login()获取
>
> \4.     将code发送给当前应用的服务器
>
> \5.     当前应用的服务器将code + appID + appSecret发送给腾讯服务器换取:{openId, sessionKey}

 ![image-20200411222618014](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222618014.png)

## 7.17. 小程序支付流程: 

[https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_4&index=3#](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_4&index=3)

\1.     请求下单支付： 将商品信息发送给商家服务器

\2.     获取openId: 从腾讯服务器获取当前用户的唯一标识

\3.     统一下单支付: 获取预支付的订单，总价，将预支付订单信息返给客户端

\4.     用户确认支付： wx.requestPayment发送请求给腾讯服务器请求扣款

\5.     等待支付结果： 客户端等待(展现给用户看的)， 商家服务器等待(更新订单状态)

 ![image-20200411222638065](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222638065.png)

# 8.  项目开发遇到问题及解决方案

## 8.1. fastClick的300ms延迟解决方案

### 8.1.1. 问题剖析:

\1.    移动端浏览器在派发点击事件的时候，通常会出现300ms左右的延迟

\2.    原因: 移动端的双击会缩放导致click判断延迟

### 8.1.2. 解决方案: fastclick库

 ![image-20200411222653503](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222653503.png)

 

实现原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉

## 8.2. 外链样式页面刷新页面样式丢失问题

### 8.2.1. 问题剖析: 

项目通常需要一份重置样式文件reset.css, 而该文件通常放在static中通过link引入，

<link rel="stylesheet" href="./static/css/reset.css">， 但在子路由组件中刷新页面会发现重     置样式文件失效，原因是加载路径错误

### 8.2.2. 解决方案:

去掉点, 将相对路径改成绝对路径

## 8.3. scoped下修改第三方样式数据(深度选择器)

### 8.3.1. 问题剖析: 

在Vue组件化开发中为了避免组件之间样式冲突问题，可在style标签中加上scoped属性，等同于设置样式作用域，只在当前的组件生效，其原理就是给当前的选择器后添加一个随机生成的唯一的属性字段（swiper-container[**data-v-7c66a6a2**]），但如果需要在有scoped的组件中修改外部组件的样式(想修改swiper库的样式),因为scoped的限制问题就无法修改

### 8.3.2. 解决方案:

\1.     使用深度选择器: 原生css样式使用 >>>, 在stylus，sass，less中使用 /deep/

\2.     语法示例: 外层选择器 /deep/ 修改样式的选择器

```
<**style** **lang=****"stylus"** **rel=****"stylesheet/stylus"** **scoped**>  **#homeContainer **   .**swiper-container **    **width** 500**px **    **height** 300**px **    **border** 1**px solid **    .**swiper-wrapper **     **width** 100%     **height** 100%     .**swiper-slide **      **width** 100%      **height** 100%    /deep/ .**swiper-pagination-bullet-active **     **width** 20**px **     **height** 20**px **     **background** **red **  
```

## 8.4. params传参刷新参数丢失问题

### 8.4.1. 问题剖析: 

\1.     vue-router进行路由跳转的时候可通过params传参

\2.     如果在注册路由的时候没有使用占位符进行注册: ‘/home/:id’,首次路由跳转可以获取params参数，再次刷新页面params数据丢失

### 8.4.2. 解决方案:

**注册路由的时候写好占位符**

```
**export default** [  {   **path**: **'/home/:id'**,   **component**: Home,   **name**: **'home'**,   **meta**: {    **isShow**: **true **   }  } ]``<**router-link** **:to=****"**{name: **'home'**, params: {id: 1}}**"**>home``<**router-link** **:to=****"/****home/1"**>home
```

 

## 8.5. map文件过大问题 

### 8.5.1. 问题剖析: 

\1.     打包生成的dist文件中的文件是压缩文件，如果发生错误不能很好的提示是哪里出了问题

\2.     .map文件就是为了提示用户哪里出了问题

 ![image-20200411222753174](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222753174.png)

### 8.5.2. 解决方案

\1.     实际项目上线文件是不需要.map文件的，如果没有去掉无形导致项目体积增大

\2.     vue-cli2: 设置修改config/index ==> productionSourceMap: false

\3.     vue-cli3设置修改: vue.config.js ==> productionSourceMap: false

## 8.6. 生产环境 & 开发环境解决跨域问题

### 8.6.1. 问题剖析: 

\1.     跨域: 浏览器为了安全起见推出了同源策略（协议，域名，端口号三者完全一样就是同源，否则就是跨域）

\2.     因为现在开发的项目都是前后端完全分离(前端有自己的服务器，如：vue脚手架服务器，同时还有服务器端服务器)的项目，必然存在跨域问题

### 8.6.2. 解决方案之开发环境跨域:

\1.     配置正向代理

\2.     思路: 页面请求本地服务器，本地服务器通过配置手动转换请求的服务器地址，请求服务器： /api/home --à http://m.you.163.com/home

\3.     vue-cli2配置: config/index.js文件中配置

```
**proxyTable**: {  **'/api'**: { *//* *匹配所有以* *'/api'**开头的请求路径 *   **target**: **'http://m.you.163.com'**, *//* *代理目标的基础路径 *   **changeOrigin**: **true**, *//* *支持跨域 *   **pathRewrite**: {*//* *重写路径**:* *去掉路径中开头的**'/api' *    **'^/api'**: **'' **   }  } },
```

 

\4.     vue-cli3配置: vue.config.js文件中配置

```
**devServer: {**``  **open: true,**``  **proxy: {**``   **//** **处理以****/api****开头路径的请求**``   **'/api': {**``    **target: 'http://localhost:4000', //** **转发的目标地址**``    **pathRewrite: {**``     **'^/api' : '' //** **转发请求时去除路径前面的****/api**``    **},**``    **changeOrigin: true, //** **如果协议****/****主机也不相同****,** **必须加上**``   **},**``  **}**``**},**
```

 

### 8.6.3. 解决方案之生产环境跨域:

\1.     后台使用CORS解决跨域，存在风险，容易被人恶意攻击

\2.     使用nginx反向代理

\3.     思路: 页面请求发送给nginx服务器，nginx根据配置动态匹配要请求的服务器地址，最终的请求由nginx服务器发出解决跨域

>   # 指向前台应用打包后文件位置  location / {    root  D:\work\190418\video\day07\online\admin_browser; # 前台应用的根路径    index index.html; # 默认index页面  #  try_files $uri $uri/  /index.html; # 总是返回首页  }     # 配置react项目的后台接口  location /api/ {    proxy_pass  http://127.0.0.1:5000/;  `}`

## 8.7. 使用swiper & better-scroll生成多个实例只有一个生效

### 8.7.1. 问题剖析: 

\1.     使用swiper或者better-scroll的时候需要实例化，一下以swiper为例说明，在new Swiper的时候通常传递一个class类名，其目的是为了让swiper找到页面中对应的DOM对象从而在该DOM对象上产生作用

\2.     当一个页面中同时new多个swiper或者better-scroll的时候，使用的class类名一样的话则最先new的那个swiper生效，其他的无效

\3.     场景: 当封住一个swiper或者better-scroll组件的时候在一个页面复用，最先使用的那个swiper组件能够使用，其他的失效

### 8.7.2. 解决方案:

​     **将class****换成ref**

## 8.8. swiper或者better-scroll在页面加载后不生效

### 8.8.1. 问题剖析

new的时机太早，在实例化对象的时候页面的数据还没有到达或者没有渲染完成

### 8.8.2. 解决方案

> \1.     目标: 想办法在列表数据更新显示之后才去创建swiper
>
> \2.     方式一: 使用watch+$nextTick()
>
> \3.     方式二: 使用回调+$nextTick()
>
> \4.     方式三: 利用dispatch()返回的promise

## 8.9. Vue实例的响应式属性 VS 非响应式属性

### 8.9.1. 问题剖析

\1.     响应式式属性

> (1)   Vue实例初始化之前定义在data中的属性
>
> (2)   修改响应式属性之后，会触发视图更新   

\2.     非响应式属性

(1)   直接通过this.xxx = value添加的属性是非响应式属性

```
data(){``this.age = 3 // age不是响应式的  **return** {   obj: { // obj是响应式属性    name: 'kobe' // name也是响应式属性** **   }  } },
```

 

### 8.9.2. 解决方案

\1.     使用Vue.set() 或this.$set(target, propertyName, value)

\2.     示例: this.obj.age = 30 --à this.$set(this.obj, 'age', 30)

## 8.10. 需求：路由组件再次被切换回来的时候如何停留在之前页面滚动的位置

### 8.10.1. 问题剖析

想要保留路由组件之前页面滚动的位置就要保留之前的状态

### 8.10.2. 解决方案  

\1.     使用keep-alive缓存路由组件

\2.     说明： keep-alive会缓存动态组件，而不是销毁，也就是意味着下次加载缓存组件的时候不会去new新的实例组件，同时状态也会用缓存之前的状态，即使再次加载组件的时候里边的状态有更新

### 8.10.3. 追问：如果在keep-alive缓存的动态路由组件中有一个组件需要加载的时候即使更新状态怎么办，因为keep-alive的特性是缓存组件之前的状态

解决方案： 使用keep-alive的include或者exclude属性，将需要及时刷新的路由组件排除

 ![image-20200411222938236](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411222938236.png)

 

# 9.  项目性能优化

## 9.1. UI库按需加载(打包)问题

### 9.1.1. 问题剖析: 

​     当开发的项目需要引入第三方的UI组件库(antd/mint-ui/element-ui)的时, 需要会打包所有组件的js和css, 而项目中只使用了其中少部分组件. 使用按需打包实现只打包使用的组件, 从而减小打包文件大小

### 9.1.2. 解决方案:

下载bebel插件包: [**babel-plugin-component**](https://github.com/QingWei-Li/babel-plugin-component)
 添加配置: babel.config.js

```
plugins: [

[“component”, { // 使用babel-plugin-component插件包

“libraryName”: “mint-ui”, // 针对特定的库

“style”: true // 相关样式自动引入

}]

]

 
```



## 9.2. 路由组件懒加载

### 9.2.1. 问题剖析: 

\1.     Vue开发中使用路由跳转页面时，通常会注册多个路由，对应的有多个路由组件

\2.     在Vue打包后文件非常之大，如果没有路由懒加载的话，一上来加载所有页面的文件

\3.     如果同时加载所有页面的文件内容的话会导致首屏加载显示过慢，甚至白屏，导致用户体验差

### 9.2.2. 解决方案

  

```
const Home = ()  => import('../pages/Home/Home.vue'); 
const Search =  () => import('../pages/Search/Search.vue');  const  CategoryList = () => import('../pages/CategoryList/CategoryList.vue');  const Recommend  = () => import('../pages/Recommend/Recommend.vue'); 
const ShopCart =  () => import('../pages/ShopCart/ShopCart.vue'); 
const Profile =  () => import('../pages/Profile/Profile.vue');  
```

 

## 9.3. React性能优化值 shouldComponentUpdate

### 9.3.1. 问题剖析

\1.     shouldComponentUpdate在组件的props，state发生变化的时候即将调用componentWillUpdate之前调用

\2.     该生命周期函数必须返回一个布尔值，true代表继续更新，false停止本次更新，即不会创建新的虚拟DOM数去进行DOM虚拟算法比较, 而默认值是true

### 9.3.2. 解决方案

\1.     方式一: 在shouldComponentUpdate中可以获取最新的nextProps，nextState，根据实际情况判断是否需要重新更新，如果不需要则return false;

\2.     方式二: 不实现Component, 而去实现PureComponent

## 9.4. 图片懒加载

### 9.4.1. 问题剖析

当一个项目图片过多的时候如果一次性加载渲染代价较大，导致用户看到的效果时间延迟

### 9.4.2. 解决方案

> \1.     npm install vue-lazyload
>
> \2.     声明使用: Vue.use(VueLazyLoad, {loading: loading图片})
>
> \3.     组件使用: <img v-lazy="item.primaryPicUrl" alt="新品">

## 9.5. webpack打包优化

### 9.5.1. 优化打包文件

1)     **目标:** 
 兼容性 / 减小打包文件/ 懒加载 / 预加载 / 首屏加载优化

**2)**     **技巧:**

 ![image-20200411223152704](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411223152704.png)

### 9.5.2. 优化打包

1)     **目标:** 
 加快打包 / 提升开发调试体验

**2)**     **技巧:**

 ![image-20200411223203927](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411223203927.png)

## 9.6. HTML性能优化

> Ø HTML标签有始终。 减少浏览器的判断时间
>
> Ø 把script标签移到HTML文件末尾，因为JS会阻塞后面的页面的显示。
>
> Ø 减少iframe的使用，因为iframe会增加一条http请求，阻止页面加载，即使内容为空，加载也需要时间
>
> Ø id和class，在能看明白的基础上，简化命名，在含有关键字的连接词中连接符号用'-'，不要用'_'
>
> Ø 保持统一大小写，统一大小写有利于浏览器缓存，虽然浏览器不区分大小写，但是w3c标准为小写
>
> Ø 清除空格，虽然空格有助于我们查看代码，但是每个空格相当于一个字符，空格越多，页面体积越大，像google、baidu等搜索引擎的首页去掉了所有可以去掉的空格、回车等字符，这样可以加快web页面的传输。可以借助于DW软件进行批量删除 html内标签之间空格，sublime text中ctrl+a，然后长按shift+tab全部左对齐，清除行开头的空格
>
> Ø 减少不必要的嵌套，尽量扁平化，因为当浏览器编译器遇到一个标签时就开始寻找它的结束标签，直到它匹配上才能显示它的内容，所以当嵌套很多时打开页面就会特别慢。
>
> Ø 减少注释，因为过多注释不光占用空间，如果里面有大量关键词会影响搜索引擎的搜索
>
> Ø 使用css+div代替table布局，去掉格式化控制标签如：strong，b，i等，使用css控制
>
> Ø 代码要结构化、语义化
>
> Ø css和javascript尽量全部分离到单独的文件中

## 9.7. css性能优化

> Ø 多利用继承，多个子元素公用的样式，如果该样式能继承的话就写在父元素身上
>
> Ø 尽量减少重绘重排的次数
>
> Ø 选择器命名规范，通过id寻找更快
>
> Ø 动画区域开启独立的图层
>
> ​       n 定位： position: absolute/relative
>
> ​       n Will-change: xxx;
>
> Ø 合并、压缩你的css文件，减少http请求，可以借助工具或者自动化构建。
>
> Ø 使用CSS sprite来处理你的图片

 

## 9.8. JS性能优化

> \1.    合并压缩js
>
> \2.    减少对DOM的操作，避免重绘重排
>
> \3.    减少请求的个数，节省网络资源
>
> \4.    封装功能函数实现复用
>
> \5.    循环语句中避免定义变量
>
> \6.    慎用闭包
>
> \7.    函数节流，函数防抖

## 9.9. 封装组件

### 9.9.1. 问题剖析

\1.    一个大型项目中内容足够复杂，在很多页面中部分内容是重复的

\2.    如果不做任何处理导致代码冗余，不利于提高性能

### 9.9.2. 解决方案

\1.    抽取封装组件

\2.    封装组件思想: 

> a)     组件内部保留相同的内容
>
> b)    不同的内容抽取出来由使用者传递进组件内部，提供组件的复用性
>
> c)     组件内部可提前声明规定用户传递的参数的必要性和数据类型
>
> d)    通过标签属性的形式传递，在组件内部通过props接收

# 10.     经典问题解析

## 10.1. MVC和MVVM的区别

### 10.1.1. MVC

 ![image-20200411223338807](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411223338807.png)

**Model****（模型）**是应用程序中用于处理应用程序数据逻辑的部分。
 　通常模型对象负责在数据库中存取数据。

**View****（视图）**是应用程序中处理数据显示的部分。
 　通常视图是依据模型数据创建的。

**Controller****（控制器）**是应用程序中处理用户交互的部分。
 　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

最典型的MVC就是JSP + [servlet](https://baike.baidu.com/item/servlet) + [javabean](https://baike.baidu.com/item/javabean)的模式

### 10.1.2. MVVM

\1.     M： Model模型, 也就是包含数据的js对象(只包含属性, 不包含方法)

\2.     V： View视图，动态显示模型对象中的数据显示界面

\3.     VM： ViewModel视图模型, 本质是一个绑定器, 通过vm读取model中的数据显示到view上, 同时view输入数据改变, vm也可以将输入数据保存到model中

\4.     图解

 ![image-20200411223355808](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411223355808.png)

\5.     MVVM的优势: 不用亲自操作DOM, 数据是响应式的, 一旦数据变化

## 10.2. 两个独立html页面怎么通信

### 10.2.1. 问题描述:

如：淘宝A，B页面，A为商品页，B为购物车页，两个页面同时打开,在A页面点击商品添加至购物车，切换到B页面购物车怎么显示该商品信息

### 10.2.2. 解决方案

\1.     利用localStroage，A页面将数据存入localStroage，B页面读取localStorage中的数据

\2.     关键点: B页面如何知道A页面什么时候存数据到localStorage

\3.     localStorage中有个‘storage’事件

\4.     window.addEventListener(‘storage’, callback)，A页面存数据，B页面监听事件

\5.     代码示例

A页面

```
  <**button** **id=****"add"**>添加一件商品到购物车</**button**>    <**button**  **id=****"del"**>删除一件商品从购物车</**button**>   <**script** **type=****"text/javascript"**>     **window**.**onload** = **function** () {      document.getElementById(**'add'**).**onclick** = **function** () {       *count*(**true**)      }         document.getElementById(**'del'**).**onclick** = **function** () {       *count*(**false**)      }         **function** *count*(flag) {       **let** count = **localStorage**.getItem(**'count'**)?***JSON\***.parse(**localStorage**.getItem(**'count'**)).**count**:0;       **if**(flag){        count += 1;       }**else** {        **if**(!count) **return**;        count -= 1;       }       **let** countObj = {        count       }       **localStorage**.setItem(**'count'**, ***JSON\***.stringify(countObj))      }     }  
```

 

B页面

```
  <**div** **class=****"cart"**>    购物车产品数量:    <**span**  **class=****"count"**>0</**span**>   </**div**>   <**script** **type=****"text/javascript"**>      document.querySelector(**'.count'**).**textContent** = **localStorage**.getItem(**'count'**)?***JSON\***.parse(**localStorage**.getItem(**'count'**)).**count**:0;      **window**.addEventListener(**'storage'**, **function** (event) {       **console**.log(***JSON\***.parse(event.**newValue**).**count**);       document.querySelector(**'.count'**).**textContent** = ***JSON\***.parse(event.**newValue**).**count **     })   </**script**>  
```



## 10.3. 在React或Vue中在子组件能不能修改props数据

### 10.3.1. 问题描述

\1. 父组件通过标签属性的形式向子组件传递数据

\2. 传递的数据类型： 基本数据类型，引用数据类型

### 10.3.2. 答案

\1. React不能修改，修改会报错

\2. Vue中可以修改，会有警告

### 10.3.3. 追问：Vue子组件修改props的数据会不会影响父组件的状态值

\1. 如果传递的基本数据类型，不会影响

\2. 如果传递的引用数据类型，会影响

## 10.4. 浏览器的同源策略

### 10.4.1. 同源 

协议、域名、端口都相同

### 10.4.2. 同源策略

> 是浏览器最核心也最基本的安全功能，主要体现在同源策略会限制来自不同源的文档和脚本对当前源的文档数据的读取或设置某些属性，是用于隔离潜在恶意文件的重要安全机制

### 10.4.3. 同源策略控制了不同源的交互

> \1.     跨域写： 默认允许，比如<a>、重定向和表单提交
>
> \2.     跨域资源嵌入： 默认允许, 比如: <script> / <link> / <img> / <video> / <audio> / <iframe>
>
> \3.     跨域读: 默认不允许, 比如ajax请求, 读取跨域的Cookie, localStorage, sessionStorage
>
>  

## 10.5. XSRF/CSRF攻击

### 10.5.1. [什么是XSRF](https://www.jianshu.com/p/0e52c58cf93f)

CSRF（Cross Site Request Forgery, 跨站域请求伪造）也称 XSRF, 是一种网络攻击方式

### 10.5.2. 攻击的原理

\1. 就是利用由于浏览器的同源策略对嵌入资源不做限制的行为进行跨站请求伪造的

\2. 原理分析图

 ![image-20200411223515824](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411223515824.png)

### 10.5.3. 解决方案

\1. referer请求头

\2. Token

\3. userId 

## 10.6. XSS攻击

### 10.6.1. [什么是XSS攻击](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/)

跨站脚本攻击(Cross Site Scripting), 因简称是CSS同样式表css重合，所以改名叫XSS

### 10.6.2. 攻击原理

> 是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，将包含js脚本的内容提交后台, 后台没有进行验证过滤返回给浏览器端显示。
>
> 例如发布评论，提交含有 JavaScript 的内容文本, 这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本
>
> 场景：用户评论：

**正常情况：**

> 用户A提交评论内容为 字符串‘我要好好学习，天天向上’，服务器获取参数
>
> 在返回的评论数据中添加该字符串，前后获取遍历显示在页面，结果: <p>我要好好学习，天天向上</p>

​     **xss****攻击:**

> ​     提交评价内容为: ‘<a href='东京热'>我要好好学习，天天大保健</a>’服务器获取参数在返回的评论数据中添加该字符串，前后获取遍历显示在页面，结果: <p><a href='xxx'>我要好好学习，天天大保健</a></p>

### 10.6.3. 解决方案

> \1. 如果提交的内容不能是html, 后台需要进行检查报错或去除标签结构, 只留下纯文本
>
> \2. 如果提交的内容可以包含html, 后台需要读取出其文本内容再组织成html结构
>
> \3. 验证请求的referer信息
>
> \4. 进行token验证

## 10.7. Vue单页面应用中刷新页面，Vuex数据丢失

### 10.7.1. Vuex特点

\1.     Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存

\2.     当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失

### 10.7.2. 如何解决

\1.     Vuex的数据都是每次组件加载时候动态请求获取数据保存

> a)     优点： 保证数据不会丢失
>
> b)    缺点: 性能差，因为网络问题可能有网络延迟

\2.     将Vuex中的数据每次同步更新保存到sessionStorage中

> a)     优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
>
> b)    缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

\3.     在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取

a)     优点: 减少动态更新sessionStorage的次数，性能好

b)    重点: 给window绑定beforeupload事件监听

 ![image-20200411223625395](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200411223625395.png)

 